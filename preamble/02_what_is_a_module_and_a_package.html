<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is a module, a component, and a package? - Cabal User Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A user friendly guide on how to get up and running with Cabal">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Preamble</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> What do we mean when we say cabal?</div></li><li class="chapter-item expanded "><a href="../preamble/02_what_is_a_module_and_a_package.html" class="active"><strong aria-hidden="true">2.</strong> What is a module, a component, and a package?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> What is hackage?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> How to install software with cabal-install</div></li><li class="chapter-item expanded affix "><li class="part-title">New To Cabal</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Installing cabal + GHC</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Cabal repl</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Cabal env</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Initializing a cabal repo</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Basic package properties</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> First cabal library</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> First cabal executable</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Adding dependencies</div></li><li class="chapter-item expanded affix "><li class="part-title">Leveling Up</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Refactoring and re-use</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> First cabal test-suite</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> First cabal benchmark</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Build products and caching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Generating documentation with haddock</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Uploading package to hackage</div></li><li class="chapter-item expanded affix "><li class="part-title">Getting Fancy</li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Setting up a cabal project</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Adding doctests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Adding local hoogle</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Flags and conditionals</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Profiling and Benchmarking</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Foreign libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Accessing data files</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Hpack</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Custom Setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Backpack</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Nix Interop</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> Stack vs cabal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> Static builds</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Cabal in CI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> Transitioning from v1 to v2</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Cabal User Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/haskell/cabal-userguide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        
                        <a href="https://github.com/haskell/cabal-userguide/edit/main/src/preamble/02_what_is_a_module_and_a_package.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-a-module-a-component-and-a-package"><a class="header" href="#what-is-a-module-a-component-and-a-package">What is a module, a component, and a package?</a></h1>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>There is an ongoing initiative to standardize the terminology we use to refer to
the hierarchy of collections of code in the Haskell community. If you are
interested in reading more about this you can find a more thorough treatment
<a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/units#background">here</a>.</p>
<p>The most significant concepts in this chapter all refer to ways of dividing and
aggregating code. They form a hierarchy, and are somewhat defined in terms of
each other. Here is a list of them in order from smallest to largest:</p>
<ol>
<li><strong>Module</strong> - The smallest unit of code defined by GHC and the Haskell
language specification. A module always coincides with a file and cabal
requires that the module name corresponds to the filename.</li>
<li><strong>Component</strong> - A component is a collection of modules. These can be a
<code>library</code>, <code>executable</code>, <code>test-suite</code>, and <code>benchmark</code>.</li>
<li><strong>Package</strong> - A package is a collection of components, identified by a
<code>&lt;package-name&gt;.cabal</code> file. A package is <strong>the</strong> unit of distribution in the
Haskell ecosystem, everything on Hackage is a package. A potential point of
confusion is that there are such things as GHC packages, these are in fact
closer to compiled components (there is more information on this in the link
above).</li>
<li><strong>Project</strong> - A project is a grouping of several related packages, denoted by
a <code>cabal.project</code> file in the root directory.</li>
</ol>
<p>Projects are not covered here, but they do have their own
<a href="../getting_fancy/01_setting_up_a_cabal_project.html">chapter</a></p>
<h2 id="what-is-a-module"><a class="header" href="#what-is-a-module">What is a module?</a></h2>
<blockquote>
<p>This section takes inspiration from the introduction to a paper on the formal
specification of the Haskell module system. While the paper goes into the deep
end of things fairly quickly the introduction is approachable. I encourage you
to give it a look
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.113.4699&amp;rep=rep1&amp;type=pdf">here</a></p>
</blockquote>
<p>Modules are a common feature in most programming languages, and tend to serve
three purposes:</p>
<ul>
<li>Namespace</li>
<li>Abstraction</li>
<li>Separate Compilation</li>
</ul>
<p>Here are some examples of how modules can be used to control the entities they
expose, and how import syntax can be used to control what is brought into scope.</p>
<p>Modules can export all of their entities.</p>
<pre><code class="language-haskell">module ExportAll where

id :: a -&gt; a
id a = a

compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
compose f g = \a -&gt; f (g a)
</code></pre>
<p>They can export a subset of entities.</p>
<pre><code class="language-haskell">module Identity (
  Identity(..),
  id
) where

data Identity a = Identity a

id :: a -&gt; a
id a = a

compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
compose f g = \a -&gt; f (g a)
</code></pre>
<p>They can also explicitly export all of their entities.</p>
<pre><code class="language-haskell">module Composition (
  compose
) where

compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
compose f g = \a -&gt; f (g a)
</code></pre>
<p>Imports of modules can be qualified with a prefix.</p>
<pre><code class="language-haskell">import qualified Identity
import qualified Composition as C

identity :: a -&gt; a
identity = C.compose Identity.id Identity.id
</code></pre>
<p>Imports can explicitly describe a few entities to bring into scope.</p>
<pre><code class="language-haskell">import Identity (id)
import Composition (compose)

identity :: a -&gt; a
identity = compose id id
</code></pre>
<p>Imports can explicitly hide a few entities and bring the rest into scope.</p>
<pre><code class="language-haskell">import ExportAll hiding (compose)
import Composition (compose)

identity :: a -&gt; a
identity = compose id id
</code></pre>
<p>If you want to learn more about Haskell modules and their syntax, then the
<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch5.html">haskell2010 report</a>
is a good place to start.</p>
<p>Alright, back to the three primary features of a module, lets look at how they
manifest in Haskell.</p>
<h4 id="namespace"><a class="header" href="#namespace">Namespace</a></h4>
<p>At its most basic, a module is a namespace for collecting language specific
primitives. In Haskell these are types, functions, and typeclasses (referred to
as entities). This is by far the most common use case (as opposed to abstraction
or trying to manipulate recompilation) in a Haskell application. Namespaces
prevent the collision of homophonous entities, but regardless of collisions,
they are often used to create semantic divisions in the structure of code
(usually in a way that reflects domain specific concepts).</p>
<p>It is good practice to make heavy use of namespaces; an 80 line file is much
more approachable, and easy to take in at a glance, than a 1000 line file.</p>
<h4 id="abstraction"><a class="header" href="#abstraction">Abstraction</a></h4>
<p>First off, what is an abstraction? It is effectively a separation of the
external API from the internal implementation. One can accomplish this with
modules by exporting a subset of entities, thus making the external API smaller
and hiding some of the internals.</p>
<p>The ML family of languages (of which Haskell is a descendant) in particular are
known for having a very robust
<a href="https://jozefg.bitbucket.io/posts/2017-01-08-modules.html">module system</a>, one
which is very good at creating expressive abstractions. While Haskell is related
to the ML family it does not have support for ML style modules, OCaml is an
example of a modern language that does have full blown ML modules. There is an
attempt at adding partial support for ML modules to Haskell, the project is
called <a href="../getting_fancy/10_backpack.html">backpack</a> but that's a slightly more
advanced topic.</p>
<p>Unlike ML modules, Haskell modules are not first class, they cannot be passed
around as values; Haskell modules are bound to a single file. They can however,
still provide a level of abstraction by limiting exports and creating opaque
types.</p>
<pre><code class="language-haskell">module Money (
  -- Notice that the constructor of PositiveDollar is not exported below
  PositiveDollar,
  -- PositiveDollar(..), &lt;- this would export the constructors as well
  mkPositiveDollar
) where

newtype PositiveDollar = PositiveDollar { unPositiveDollar :: Int }

mkPositiveDollar :: Int -&gt; Maybe PositiveDollar
mkPositiveDollar n
  | n &gt;= 0 = Just . PositiveDollar $ n
  | otherwise = Nothing
</code></pre>
<blockquote>
<p>Note: If you want to learn more about opaque types and their use cases this
<a href="https://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/modules.html">resource</a>
is fantastic</p>
</blockquote>
<p>Now a consumer of the <code>Money</code> module can only construct a <code>PositiveDollar</code> by
calling <code>mkPositiveDollar</code>, which ensures PositiveDollar can only ever be
created from a non-negative <code>Int</code>. Handling negatives has been abstracted away
from the end user!</p>
<h4 id="separate-compilation"><a class="header" href="#separate-compilation">Separate Compilation</a></h4>
<p>Module separation can also impact compile times. Each module keeps track of the
fingerprint (A unique identifier, in new versions of GHC it is a hash of the
contents of the file) of the modules it depends on. If you change a module that
is depended upon by other modules, you will need to recompile everything
downstream of your change. This means that modules, when imported frequently,
can trigger a large chain of recompilations.</p>
<pre><code>
                                       Main.hs
                                      /   |   \
                                     /   / \   \
                                    A   B   C   D
                                     \   \ /   /
                                  CustomPrelude.hs

</code></pre>
<blockquote>
<p>Note: Sometimes haskell projects will define a <code>CustomPrelude.hs</code> or
<code>Import.hs</code> module to reduce the boiler plate of importing common modules /
packages. While this isn't necessarily bad, it is important to understand the
impact it can have on compilation times!</p>
</blockquote>
<p>In the diagram above, we can imagine the dependency graph flowing upwards. That
means that <code>Main.hs</code> imports <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>, and all of the lettered
modules depend on <code>CustomPrelude.hs</code>. Any change to the lettered modules will
only require a recompilation of the changed module and <code>Main.hs</code>. However, if we
make a change to <code>CustomPrelude.hs</code> then every single module needs to be
recompiled.</p>
<p>We could do something like split up <code>CustomPrelude.hs</code> into a module that is
depended upon by <code>A</code> and <code>B</code> and another that is depended upon by <code>C</code> and <code>D</code>.
This means that changes in <code>PreludeAB.hs</code> now only recompile <code>A</code> and <code>B</code> and the
same for <code>PreludeCD.hs</code> and <code>C</code> and <code>D</code>. In this way we reduce overall compile
times by making it clear to GHC, at the module level, which code depends on
what. GHC will use this information to see what work it has already done that is
still valid, and what needs to be re-computed.</p>
<pre><code>
                                       Main.hs
                                      /   |   \
                                     /   / \   \
                                    A   B   C   D
                                   /   /     \   \
                              PreludeAB.hs   PreludeCD.hs

</code></pre>
<blockquote>
<p>Note: Main.hs has to be recompiled every time, regardless, so it does help if
you can move code that doesn't change frequently down the dependency graph.</p>
</blockquote>
<p>For a deeper exposition of module recompilation the
<a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/recompilation-avoidance">GHC docs</a>
are a great resource.</p>
<p>A crucial point to understand here is that <code>GHC</code> is responsible for this
recompilation logic, and a modules capabilities are defined in the Haskell
language specification. Why is it important for us, as cabal users, to
understand the module dependency graph, and how to use modules in general?</p>
<p>The answer is two-fold:</p>
<ol>
<li>We will often interface with GHC's recompilation functionality through
<code>cabal</code> with commands like <code>cabal build</code> and <code>cabal repl</code>.</li>
<li>The module is the smallest unit of concern within cabal, and therefore it is
worthwhile to understand its meaning, use cases, and impact on our codebase.</li>
</ol>
<h2 id="what-is-a-component"><a class="header" href="#what-is-a-component">What is a Component?</a></h2>
<p>If a module is the construct for managing an internal dependency, then
components are the construct for managing external dependencies. Components
aggregate all of our internal dependencies to be exposed externally, and
components also declare all of the external packages that we depend on so that
they can be made available as modules within our code.</p>
<p>When arranging components Cabal needs to be aware of all the modules that we
would like to expose externally. Now <em>what</em> we choose to expose is up to us.
Sometimes we just want to write an application, in which case we don't need to
expose any modules, just the <code>main</code> entrypoint that gets called when we run our
executable. Sometimes we want to write a library for others to use, and we want
to liberally expose everything. Sometimes we want to write a library with some
nasty internal machinery which we would prefer to keep hidden, and only expose
the clean external api. All of these use cases can be expressed using
components.</p>
<p>Components are represented by top level declarations within a <code>.cabal</code> file.
There are four keywords (corresponding to the four kinds of components);
<code>library</code>, <code>executable</code>, <code>test-suite</code>, and <code>benchmark</code>. There can be multiple
components of the same type declared in the same <code>.cabal</code> file. Components
should all be given a name, except for libraries, which can be unnamed. A
<strong>library</strong> exposes several modules which are intended to be used by other
packages. An <strong>executable</strong> produces a compiled binary that can be executed. A
<strong>test suite</strong> is a program that can be invoked like an executable but it
generally just tests code that is internal to the package. A <strong>benchmark</strong> is
used to measure the performance characteristics of another component.</p>
<blockquote>
<p>Note: each of these components will receive individual treatment later on in
the guide. If you are interested to take a peek now you can find them here:
<a href="../new_to_cabal/06_first_cabal_library.html">library</a>,
<a href="../new_to_cabal/06_first_cabal_executable.html">executable</a>,
<a href="../leveling_up/02_first_cabal_test_suite.html">test-suite</a> &gt;
<a href="../getting_fancy/05_profiling_and_benchmarking.html">benchmark</a></p>
</blockquote>
<p>There are specific field names that we use to enumerate modules within
components: <code>exposed-modules</code>, <code>other-modules</code>, <code>virtual-modules</code>,
<code>test-module</code>, and even <code>main-is</code> which describes the entrypoint module for an
executable. These fields are contained within the top level component
declarations (mentioned above).</p>
<p>External dependencies are also contained within a top level component
declaration, under the <code>build-depends</code> label. There are also foreign
(non-Haskell) dependencies, which live under the <code>foreign-library</code> field name.
There are also <code>c-sources</code>, <code>extra-libraries</code>, <code>includes</code> and
<code>install-includes</code>, but these are more advanced. These are a bit anomalous in
the sense that they are not associated with a single component, there is a
separate <a href="../getting_fancy/06_foreign_libraries.html">chapter</a> on them.</p>
<p>It is not necessary to commit these fields to memory, but it is good to be aware
of them. Hopefully when you look at the layout of a <code>.cabal</code> file next, you will
see the <code>package &lt;- component &lt;- module</code> hierarchy reflected in the nested
fields!</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a package?</a></h2>
<p>If a module is the smallest unit of code in cabal, a <strong>package</strong> is the largest
unit of distribution. At its core, a package is just a distributable artefact
that provides access to components.</p>
<blockquote>
<p>You might remember cabal projects from earlier, as being <em>upstream</em> of
packages. Good catch, a <strong>project</strong> is bigger than a package in the sense that
it is a grouping of packages, but a project is not distributed; you will not
see a cabal project on Hackage.</p>
</blockquote>
<p>The <code>.cabal</code> file represents a single package, and is really just a collection
of metadata about the package's constituent parts. It defines the package's
components, its internal dependency structure (list of modules), and the
package's external dependencies; usually other packages.</p>
<p>To make things more concrete, here is a pseudo-Haskell type representing the
package-component-module hierarchy:</p>
<pre><code class="language-haskell">data Module =
  Module
    { moduleName :: Text
    , moduleEntities :: [Entities]
    , moduleExports :: [Entities]
    , moduleModuleImports :: [Module]
    }

data ComponentType = Executable | Library | TestSuite | Benchmark

data Component =
  Component
    { componentName    :: Text
    , componentType    :: ComponentType
    , componentModules :: [Module]
    }

type Package = [Component]
</code></pre>
<blockquote>
<p>Note: technically a package can contain no components, but if you try and run
<code>cabal build</code> you will get a message suggesting that the omission may be
erroneous.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Cabal is a tool for defining and building Haskell packages. Even if we don't
intend to distribute our code, we can still think of it as an unrealized
package. This is important because, inherent in the definition of a package, are
all of its dependencies. This is a very common use case for cabal; to bring a
bunch of dependencies in to scope so that we can explore them and call them from
our own code. This workflow, in which the code is not intended to be published
(or even saved), is facilitated by commands like <code>cabal repl</code>, <code>cabal exec</code>, and
<code>cabal env</code> (which is being worked on currently).</p>
<p>Therefore it is informative to think of cabal as handling several distinct
concerns:</p>
<ol>
<li>Describing the internal dependency structure of a package in terms of
modules.</li>
<li>Managing the external dependencies of our project and allowing us to access
them from within our modules.</li>
<li>Managing the building and distribution of our package, which is really just a
collection of components.</li>
</ol>
<p>I believe that the reader of this guide will get the most out of it if they
consider which of these functions they are interested in performing with Cabal.
Hopefully understanding these distinct considerations will reveal some of the
intention behind subsequent sections!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
